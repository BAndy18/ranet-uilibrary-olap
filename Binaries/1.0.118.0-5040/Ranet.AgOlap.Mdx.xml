<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Ranet.AgOlap.Mdx</name>
    </assembly>
    <members>
        <member name="T:Antlr.Runtime.ANTLRFileStream">
            <summary>
            A character stream - an <see cref="T:Antlr.Runtime.ICharStream"/> - that loads 
            and caches the contents of it's underlying file fully during 
            object construction
            </summary>
            <remarks>
            This looks very much like an ANTLReaderStream or an ANTLRInputStream 
            but, it is a special case. Since we know the exact size of the file to 
            load, we can avoid lots of data copying and buffer resizing.
            </remarks>
        </member>
        <member name="T:Antlr.Runtime.ANTLRStringStream">
            <summary>
            A pretty quick <see cref="T:Antlr.Runtime.ICharStream"/> that uses a character array 
            directly as it's underlying source.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.ICharStream">
            <summary>A source of characters for an ANTLR lexer </summary>
        </member>
        <member name="T:Antlr.Runtime.IIntStream">
            <summary>
            A simple stream of integers. This is useful when all we care about is the char
            or token type sequence (such as for interpretation).
            </summary>
        </member>
        <member name="M:Antlr.Runtime.IIntStream.LA(System.Int32)">
            <summary>
            Get int at current input pointer + i ahead (where i=1 is next int)
            Negative indexes are allowed.  LA(-1) is previous token (token just matched).
            LA(-i) where i is before first token should yield -1, invalid char or EOF.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.IIntStream.Mark">
            <summary>Tell the stream to start buffering if it hasn't already.</summary>
            <remarks>
            Executing Rewind(Mark()) on a stream should not affect the input position.
            The Lexer tracks line/col info as well as input index so its markers are
            not pure input indexes.  Same for tree node streams.													*/
            </remarks>
            <returns>Return a marker that can be passed to 
            <see cref="M:Antlr.Runtime.IIntStream.Rewind(System.Int32)"/> to return to the current position. 
            This could be the current input position, a value return from 
            <see cref="M:Antlr.Runtime.IIntStream.Index"/>, or some other marker.</returns>
        </member>
        <member name="M:Antlr.Runtime.IIntStream.Index">
            <summary>
            Return the current input symbol index 0..n where n indicates the 
            last symbol has been read. The index is the symbol about to be
            read not the most recently read symbol.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.IIntStream.Rewind(System.Int32)">
            <summary>
            Resets the stream so that the next call to 
            <see cref="M:Antlr.Runtime.IIntStream.Index"/> would  return marker.
            </summary>
            <remarks>
            The marker will usually be <see cref="M:Antlr.Runtime.IIntStream.Index"/> but 
            it doesn't have to be.  It's just a marker to indicate what 
            state the stream was in.  This is essentially calling 
            <see cref="M:Antlr.Runtime.IIntStream.Release(System.Int32)"/> and <see cref="M:Antlr.Runtime.IIntStream.Seek(System.Int32)"/>.
            If there are other markers created after the specified marker, 
            this routine must unroll them like a stack.  Assumes the state the 
            stream was in when this marker was created.
            </remarks>
        </member>
        <member name="M:Antlr.Runtime.IIntStream.Rewind">
            <summary>
            Rewind to the input position of the last marker.
            </summary>
            <remarks>
            Used currently only after a cyclic DFA and just before starting 
            a sem/syn predicate to get the input position back to the start 
            of the decision. Do not "pop" the marker off the state.  Mark(i) 
            and Rewind(i) should balance still. It is like invoking 
            Rewind(last marker) but it should not "pop" the marker off.  
            It's like Seek(last marker's input position).
            </remarks>
        </member>
        <member name="M:Antlr.Runtime.IIntStream.Release(System.Int32)">
            <summary>
            You may want to commit to a backtrack but don't want to force the
            stream to keep bookkeeping objects around for a marker that is
            no longer necessary.  This will have the same behavior as
            <see cref="M:Antlr.Runtime.IIntStream.Rewind(System.Int32)"/> except it releases resources without 
            the backward seek.
            </summary>
            <remarks>
            This must throw away resources for all markers back to the marker
            argument. So if you're nested 5 levels of Mark(), and then Release(2)
            you have to release resources for depths 2..5.
            </remarks>
        </member>
        <member name="M:Antlr.Runtime.IIntStream.Seek(System.Int32)">
            <summary>
            Set the input cursor to the position indicated by index.  This is
            normally used to seek ahead in the input stream.
            </summary>
            <remarks>
            No buffering is required to do this unless you know your stream 
            will use seek to move backwards such as when backtracking.
            
            This is different from rewind in its multi-directional requirement 
            and in that its argument is strictly an input cursor (index).
            
            For char streams, seeking forward must update the stream state such
            as line number.  For seeking backwards, you will be presumably
            backtracking using the 
            <see cref="M:Antlr.Runtime.IIntStream.Mark"/>/<see cref="M:Antlr.Runtime.IIntStream.Rewind(System.Int32)"/> 
            mechanism that restores state and so this method does not need to 
            update state when seeking backwards.
            
            Currently, this method is only used for efficient backtracking using
            memoization, but in the future it may be used for incremental parsing.
            
            The index is 0..n-1. A seek to position i means that LA(1) will return 
            the ith symbol.  So, seeking to 0 means LA(1) will return the first 
            element in the stream.
            </remarks>
        </member>
        <member name="M:Antlr.Runtime.IIntStream.Size">
            <summary>Returns the size of the entire stream.</summary>
            <remarks>
            Only makes sense for streams that buffer everything up probably, 
            but might be useful to display the entire stream or for testing.
            This value includes a single EOF.
            </remarks>
        </member>
        <member name="P:Antlr.Runtime.IIntStream.Count">
            <summary>Returns the size of the entire stream.</summary>
            <remarks>
            Only makes sense for streams that buffer everything up probably, 
            but might be useful to display the entire stream or for testing.
            This value includes a single EOF.
            </remarks>
        </member>
        <member name="P:Antlr.Runtime.IIntStream.SourceName">
            <summary>
            Where are you getting symbols from?  Normally, implementations will
            pass the buck all the way to the lexer who can ask its input stream
            for the file name or whatever.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ICharStream.LT(System.Int32)">
            <summary>
            Get the ith character of lookahead.  This is usually the same as
            LA(i).  This will be used for labels in the generated lexer code.
            I'd prefer to return a char here type-wise, but it's probably 
            better to be 32-bit clean and be consistent with LA.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ICharStream.Substring(System.Int32,System.Int32)">
            <summary>
            This primarily a useful interface for action code (just make sure 
            actions don't use this on streams that don't support it).
            For infinite streams, you don't need this.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.ICharStream.Line">
            <summary>
            The current line in the character stream (ANTLR tracks the 
            line information automatically. To support rewinding character 
            streams, we are able to [re-]set the line.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.ICharStream.CharPositionInLine">
            <summary>
            The index of the character relative to the beginning of the 
            line (0..n-1). To support rewinding character streams, we are 
            able to [re-]set the character position.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ANTLRStringStream.#ctor">
            <summary>
            Initializes a new instance of the ANTLRStringStream class
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ANTLRStringStream.#ctor(System.String)">
            <summary>
            Initializes a new instance of the ANTLRStringStream class for the
            specified string. This copies data from the string to a local 
            character array
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ANTLRStringStream.#ctor(System.Char[],System.Int32)">
            <summary>
            Initializes a new instance of the ANTLRStringStream class for the
            specified character array. This is the preferred constructor as 
            no data is copied
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ANTLRStringStream.Reset">
            <summary>
            Resets the stream so that it is in the same state it was
            when the object was created *except* the data array is not
            touched.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ANTLRStringStream.Consume">
            <summary>
            Advances the read position of the stream. Updates line and column state
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ANTLRStringStream.LA(System.Int32)">
            <summary>
            Return lookahead characters at the specified offset from the current read position.
            The lookahead offset can be negative.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ANTLRStringStream.Index">
            <summary>
            Return the current input symbol index 0..n where n indicates the
            last symbol has been read. The index is the index of char to
            be returned from LA(1).
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ANTLRStringStream.Size">
            <summary>
            Returns the size of the stream
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ANTLRStringStream.Seek(System.Int32)">
            <summary>Seeks to the specified position.</summary>
            <remarks>
            Consume ahead until p==index; can't just set p=index as we must
            update line and charPositionInLine.
            </remarks>
        </member>
        <member name="F:Antlr.Runtime.ANTLRStringStream.data">
            <summary>The data for the stream</summary>
        </member>
        <member name="F:Antlr.Runtime.ANTLRStringStream.n">
            <summary>How many characters are actually in the buffer?</summary>
        </member>
        <member name="F:Antlr.Runtime.ANTLRStringStream.p">
            <summary>Index in our array for the next char (0..n-1)</summary>
        </member>
        <member name="F:Antlr.Runtime.ANTLRStringStream.line">
            <summary>Current line number within the input (1..n )</summary>
        </member>
        <member name="F:Antlr.Runtime.ANTLRStringStream.charPositionInLine">
            <summary>
            The index of the character relative to the beginning of the 
            line (0..n-1)
            </summary>
        </member>
        <member name="F:Antlr.Runtime.ANTLRStringStream.markDepth">
            <summary>
            Tracks the depth of nested <see cref="M:Antlr.Runtime.IIntStream.Mark"/> calls
            </summary>
        </member>
        <member name="F:Antlr.Runtime.ANTLRStringStream.markers">
            <summary>
            A list of CharStreamState objects that tracks the stream state
            (i.e. line, charPositionInLine, and p) that can change as you
            move through the input stream.  Indexed from 1..markDepth.
            A null is kept @ index 0.  Create upon first call to Mark().
            </summary>
        </member>
        <member name="F:Antlr.Runtime.ANTLRStringStream.lastMarker">
            <summary>
            Track the last Mark() call result value for use in Rewind().
            </summary>
        </member>
        <member name="F:Antlr.Runtime.ANTLRStringStream.name">
            <summary>
            What is name or source of this char stream?
            </summary>
        </member>
        <member name="P:Antlr.Runtime.ANTLRStringStream.Line">
            <summary>
            Current line position in stream.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.ANTLRStringStream.CharPositionInLine">
            <summary>
            Current character position on the current line stream 
            (i.e. columnn position)
            </summary>
        </member>
        <member name="P:Antlr.Runtime.ANTLRStringStream.Count">
            <summary>
            Returns the size of the stream
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ANTLRFileStream.#ctor">
            <summary>
            Initializes a new instance of the ANTLRFileStream class
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ANTLRFileStream.#ctor(System.String)">
            <summary>
            Initializes a new instance of the ANTLRFileStream class for the
            specified file name
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ANTLRFileStream.#ctor(System.String,System.Text.Encoding)">
            <summary>
            Initializes a new instance of the ANTLRFileStream class for the
            specified file name and encoding
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ANTLRFileStream.Load(System.String,System.Text.Encoding)">
            <summary>
            Loads and buffers the specified file to be used as this 
            ANTLRFileStream's source
            </summary>
            <param name="fileName">File to load</param>
            <param name="encoding">Encoding to apply to file</param>
        </member>
        <member name="F:Antlr.Runtime.ANTLRFileStream.fileName">
            <summary>Fully qualified name of the stream's underlying file</summary>
        </member>
        <member name="P:Antlr.Runtime.ANTLRFileStream.SourceName">
            <summary>
            Gets the file name of this ANTLRFileStream underlying file
            </summary>
        </member>
        <member name="T:Antlr.Runtime.ANTLRInputStream">
            <summary>
            A character stream - an <see cref="T:Antlr.Runtime.ICharStream"/> - that loads 
            and caches the contents of it's underlying 
            <see cref="T:System.IO.Stream"/> fully during object construction
            </summary>
            <remarks>
            Useful for reading from stdin and, for specifying file encodings etc...
            </remarks>
        </member>
        <member name="T:Antlr.Runtime.ANTLRReaderStream">
            <summary>
            An ANTLRStringStream that caches all the input from a TextReader. It 
            behaves just like a plain ANTLRStringStream
            </summary>
            <remarks>
            Manages the buffer manually to avoid unnecessary data copying.
            If you need encoding, use ANTLRInputStream.
            </remarks>
        </member>
        <member name="F:Antlr.Runtime.ANTLRReaderStream.READ_BUFFER_SIZE">
            <summary>Default size (in characters) of the buffer used for IO reads</summary>
        </member>
        <member name="F:Antlr.Runtime.ANTLRReaderStream.INITIAL_BUFFER_SIZE">
            <summary>Initial size (in characters) of the data cache</summary>
        </member>
        <member name="M:Antlr.Runtime.ANTLRReaderStream.#ctor">
            <summary>
            Initializes a new instance of the ANTLRReaderStream class
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ANTLRReaderStream.#ctor(System.IO.TextReader)">
            <summary>
            Initializes a new instance of the ANTLRReaderStream class for the
            specified TextReader
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ANTLRReaderStream.#ctor(System.IO.TextReader,System.Int32)">
            <summary>
            Initializes a new instance of the ANTLRReaderStream class for the
            specified TextReader and initial data buffer size
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ANTLRReaderStream.#ctor(System.IO.TextReader,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the ANTLRReaderStream class for the
            specified TextReader, initial data buffer size and, using 
            a read buffer of the specified size
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ANTLRReaderStream.Load(System.IO.TextReader,System.Int32,System.Int32)">
            <summary>
            Loads and buffers the contents of the specified reader to be 
            used as this ANTLRReaderStream's source
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ANTLRInputStream.#ctor">
            <summary>
            Initializes a new instance of the ANTLRInputStream class
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ANTLRInputStream.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the ANTLRInputStream class for the
            specified stream
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ANTLRInputStream.#ctor(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Initializes a new instance of the ANTLRInputStream class for the
            specified stream and encoding
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ANTLRInputStream.#ctor(System.IO.Stream,System.Int32)">
            <summary>
            Initializes a new instance of the ANTLRInputStream class for the
            specified stream and initial data buffer size
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ANTLRInputStream.#ctor(System.IO.Stream,System.Int32,System.Text.Encoding)">
            <summary>
            Initializes a new instance of the ANTLRInputStream class for the
            specified stream, encoding and initial data buffer size
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ANTLRInputStream.#ctor(System.IO.Stream,System.Int32,System.Int32,System.Text.Encoding)">
            <summary>
            Initializes a new instance of the ANTLRInputStream class for the
            specified stream, encoding, initial data buffer size and, using 
            a read buffer of the specified size
            </summary>
        </member>
        <member name="T:Antlr.Runtime.BaseRecognizer">
            <summary>
            A generic recognizer that can handle recognizers generated from
            lexer, parser, and tree grammars.  This is all the parsing
            support code essentially; most of it is error recovery stuff and
            backtracking.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.Failed">
            Return whether or not a backtracking attempt failed. 
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.Reset">
            <summary>Reset the parser's state. Subclasses must rewind the input stream.</summary>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.Match(Antlr.Runtime.IIntStream,System.Int32,Antlr.Runtime.BitSet)">
            <summary>
            Match current input symbol against ttype.  Attempt
            single token insertion or deletion error recovery.  If
            that fails, throw MismatchedTokenException.
            </summary>
            <remarks>
            To turn off single token insertion or deletion error
            recovery, override RecoverFromMismatchedToken() and have it call
            pthrow an exception. See TreeParser.RecoverFromMismatchedToken().
            This way any error in a rule will cause an exception and
            immediate exit from rule.  Rule would recover by resynchronizing
            to the set of symbols that can follow rule ref.
            </remarks>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.MatchAny(Antlr.Runtime.IIntStream)">
            <summary> Match the wildcard: in a symbol</summary>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.ReportError(Antlr.Runtime.RecognitionException)">
             <summary>
             Report a recognition problem.
             </summary>
             <remarks>
             This method sets errorRecovery to indicate the parser is recovering
             not parsing.  Once in recovery mode, no errors are generated.
             To get out of recovery mode, the parser must successfully Match
             a token (after a resync).  So it will go:
             
             1. error occurs
             2. enter recovery mode, report error
             3. consume until token found in resynch set
             4. try to resume parsing
             5. next Match() will reset errorRecovery mode
            
             If you override, make sure to update syntaxErrors if you care about that.
             </remarks>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.GetErrorMessage(Antlr.Runtime.RecognitionException,System.String[])">
            <summary>
            What error message should be generated for the various exception types?
            
            Not very object-oriented code, but I like having all error message generation 
            within one method rather than spread among all of the exception classes. This 
            also makes it much easier for the exception handling because the exception 
            classes do not have to have pointers back to this object to access utility 
            routines and so on. Also, changing the message for an exception type would be 
            difficult because you would have to subclassing exception, but then somehow get 
            ANTLR to make those kinds of exception objects instead of the default.
            
            This looks weird, but trust me--it makes the most sense in terms of flexibility.
            
            For grammar debugging, you will want to override this to add more information 
            such as the stack frame with GetRuleInvocationStack(e, this.GetType().Fullname) 
            and, for no viable alts, the decision description and state etc...
            
            Override this to change the message generated for one or more exception types.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.GetErrorHeader(Antlr.Runtime.RecognitionException)">
            <summary>
            What is the error header, normally line/character position information?
            </summary>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.GetTokenErrorDisplay(Antlr.Runtime.IToken)">
            <summary>
            How should a token be displayed in an error message? The default
            is to display just the text, but during development you might
            want to have a lot of information spit out.  Override in that case
            to use t.ToString() (which, for CommonToken, dumps everything about
            the token). This is better than forcing you to override a method in
            your token objects because you don't have to go modify your lexer
            so that it creates a new type.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.EmitErrorMessage(System.String)">
            <summary>
            Override this method to change where error messages go
            </summary>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.Recover(Antlr.Runtime.IIntStream,Antlr.Runtime.RecognitionException)">
            <summary>
            Recover from an error found on the input stream.  This is
            for NoViableAlt and mismatched symbol exceptions.  If you enable
            single token insertion and deletion, this will usually not
            handle mismatched symbol exceptions but there could be a mismatched
            token that the Match() routine could not recover from.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.BeginResync">
            <summary>A hook to listen in on the token consumption during error recovery.
            The DebugParser subclasses this to fire events to the listenter.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.RecoverFromMismatchedToken(Antlr.Runtime.IIntStream,System.Int32,Antlr.Runtime.BitSet)">
            <summary>
            Attempt to Recover from a single missing or extra token.
            </summary>
            <remarks>
            EXTRA TOKEN
            
            LA(1) is not what we are looking for.  If LA(2) has the right token,
            however, then assume LA(1) is some extra spurious token.  Delete it
            and LA(2) as if we were doing a normal Match(), which advances the
            input.
            
            MISSING TOKEN
            
            If current token is consistent with what could come after
            ttype then it is ok to "insert" the missing token, else throw
            exception For example, Input "i=(3;" is clearly missing the
            ')'.  When the parser returns from the nested call to expr, it
            will have call chain:
            
            stat -> expr -> atom
            
            and it will be trying to Match the ')' at this point in the
            derivation:
            
            => ID '=' '(' INT ')' ('+' atom)* ';'
            ^
            Match() will see that ';' doesn't Match ')' and report a
            mismatched token error.  To Recover, it sees that LA(1)==';'
            is in the set of tokens that can follow the ')' token
            reference in rule atom.  It can assume that you forgot the ')'.
            </remarks>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.RecoverFromMismatchedSet(Antlr.Runtime.IIntStream,Antlr.Runtime.RecognitionException,Antlr.Runtime.BitSet)">
            Not currently used 
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.ConsumeUntil(Antlr.Runtime.IIntStream,Antlr.Runtime.BitSet)">
            <summary>Consume tokens until one matches the given token set </summary>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.GetRuleInvocationStack">
            <summary>
            Returns List &lt;String&gt; of the rules in your parser instance
            leading up to a call to this method.  You could override if
            you want more details such as the file/line info of where
            in the parser source code a rule is invoked.
            </summary>
            <remarks>
            This is very useful for error messages and for context-sensitive
            error recovery.
            </remarks>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.GetRuleInvocationStack(System.Exception,System.String)">
            <summary>
            A more general version of GetRuleInvocationStack where you can
            pass in, for example, a RecognitionException to get it's rule
            stack trace.  This routine is shared with all recognizers, hence,
            static.
            
            TODO: move to a utility class or something; weird having lexer call this
            </summary>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.ToStrings(System.Collections.Generic.IList{Antlr.Runtime.IToken})">
            <summary>A convenience method for use most often with template rewrites.
            Convert a List&lt;Token&gt; to List&lt;String&gt;
            </summary>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.GetRuleMemoization(System.Int32,System.Int32)">
            <summary>
            Given a rule number and a start token index number, return
            MEMO_RULE_UNKNOWN if the rule has not parsed input starting from
            start index.  If this rule has parsed input starting from the
            start index before, then return where the rule stopped parsing.
            It returns the index of the last token matched by the rule.
            </summary>
            <remarks>
            For now we use a hashtable and just the slow Object-based one.
            Later, we can make a special one for ints and also one that
            tosses out data after we commit past input position i.
            </remarks>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.AlreadyParsedRule(Antlr.Runtime.IIntStream,System.Int32)">
            <summary>
            Has this rule already parsed input at the current index in the
            input stream?  Return the stop token index or MEMO_RULE_UNKNOWN.
            If we attempted but failed to parse properly before, return
            MEMO_RULE_FAILED.
            
            This method has a side-effect: if we have seen this input for
            this rule and successfully parsed before, then seek ahead to
            1 past the stop token matched for this rule last time.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.Memoize(Antlr.Runtime.IIntStream,System.Int32,System.Int32)">
            <summary>
            Record whether or not this rule parsed the input at this position
            successfully.  Use a standard hashtable for now.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.GetRuleMemoizationCacheSize">
            <summary>
            Return how many rule/input-index pairs there are in total.
             TODO: this includes synpreds. :(
            </summary>
            <returns></returns>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.ComputeErrorRecoverySet">
            <summary>
            Factor out what to do upon token mismatch so tree parsers can behave
            differently.  Override and call RecoverFromMismatchedToken()
            to get single token insertion and deletion. Use this to turn off
            single token insertion and deletion. Override mismatchRecover
            to call this instead.
            
            TODO: fix this comment, mismatchRecover doesn't exist, for example
            </summary>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.ComputeContextSensitiveRuleFOLLOW">
            <summary>Compute the context-sensitive FOLLOW set for current rule.
            This is set of token types that can follow a specific rule
            reference given a specific call chain.  You get the set of
            viable tokens that can possibly come next (lookahead depth 1)
            given the current call chain.  Contrast this with the
            definition of plain FOLLOW for rule r:
            
            FOLLOW(r)={x | S=>*alpha r beta in G and x in FIRST(beta)}
            
            where x in T* and alpha, beta in V*; T is set of terminals and
            V is the set of terminals and nonterminals.  In other words,
            FOLLOW(r) is the set of all tokens that can possibly follow
            references to r in *any* sentential form (context).  At
            runtime, however, we know precisely which context applies as
            we have the call chain.  We may compute the exact (rather
            than covering superset) set of following tokens.
            
            For example, consider grammar:
            
            stat : ID '=' expr ';'      // FOLLOW(stat)=={EOF}
            | "return" expr '.'
            ;
            expr : atom ('+' atom)* ;   // FOLLOW(expr)=={';','.',')'}
            atom : INT                  // FOLLOW(atom)=={'+',')',';','.'}
            | '(' expr ')'
            ;
            
            The FOLLOW sets are all inclusive whereas context-sensitive
            FOLLOW sets are precisely what could follow a rule reference.
            For input input "i=(3);", here is the derivation:
            
            stat => ID '=' expr ';'
            => ID '=' atom ('+' atom)* ';'
            => ID '=' '(' expr ')' ('+' atom)* ';'
            => ID '=' '(' atom ')' ('+' atom)* ';'
            => ID '=' '(' INT ')' ('+' atom)* ';'
            => ID '=' '(' INT ')' ';'
            
            At the "3" token, you'd have a call chain of
            
            stat -> expr -> atom -> expr -> atom
            
            What can follow that specific nested ref to atom?  Exactly ')'
            as you can see by looking at the derivation of this specific
            input.  Contrast this with the FOLLOW(atom)={'+',')',';','.'}.
            
            You want the exact viable token set when recovering from a
            token mismatch.  Upon token mismatch, if LA(1) is member of
            the viable next token set, then you know there is most likely
            a missing token in the input stream.  "Insert" one by just not
            throwing an exception.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.GetCurrentInputSymbol(Antlr.Runtime.IIntStream)">
            <summary>
            Match needs to return the current input symbol, which gets put
            into the label for the associated token ref; e.g., x=ID.  Token
            and tree parsers need to return different objects. Rather than test
            for input stream type or change the IntStream interface, I use
            a simple method to ask the recognizer to tell me what the current
            input symbol is.
            </summary>
            <remarks>This is ignored for lexers.</remarks>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.GetMissingSymbol(Antlr.Runtime.IIntStream,Antlr.Runtime.RecognitionException,System.Int32,Antlr.Runtime.BitSet)">
            <summary>
            Conjure up a missing token during error recovery.
            </summary>
            <remarks>
            The recognizer attempts to recover from single missing
            symbols. But, actions might refer to that missing symbol.
            For example, x=ID {f($x);}. The action clearly assumes
            that there has been an identifier matched previously and that
            $x points at that token. If that token is missing, but
            the next token in the stream is what we want we assume that
            this token is missing and we keep going. Because we
            have to return some token to replace the missing token,
            we have to conjure one up. This method gives the user control
            over the tokens returned for missing tokens. Mostly,
            you will want to create something special for identifier
            tokens. For literals such as '{' and ',', the default
            action in the parser or tree parser works. It simply creates
            a CommonToken of the appropriate type. The text will be the token.
            If you change what tokens must be created by the lexer,
            override this method to create the appropriate tokens.
            </remarks>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.PushFollow(Antlr.Runtime.BitSet)">
            <summary>
            Push a rule's follow set using our own hardcoded stack 
            </summary>
            <param name="fset"></param>
        </member>
        <member name="F:Antlr.Runtime.BaseRecognizer.state">
            <summary>
            An externalized representation of the - shareable - internal state of 
            this lexer, parser or tree parser.
            </summary>
            <remarks>
            The state of a lexer, parser, or tree parser are collected into 
            external state objects so that the state can be shared. This sharing 
            is needed to have one grammar import others and share same error 
            variables and other state variables.  It's a kind of explicit multiple
            inheritance via delegation of methods and shared state.
            </remarks>
        </member>
        <member name="P:Antlr.Runtime.BaseRecognizer.NumberOfSyntaxErrors">
             <summary>
             Get number of recognition errors (lexer, parser, tree parser).  Each
             recognizer tracks its own number.  So parser and lexer each have
             separate count.  Does not count the spurious errors found between
             an error and next valid token match
            
             See also ReportError()
             </summary>
        </member>
        <member name="P:Antlr.Runtime.BaseRecognizer.GrammarFileName">
            <summary>
            For debugging and other purposes, might want the grammar name.
            Have ANTLR generate an implementation for this property.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Antlr.Runtime.BaseRecognizer.SourceName">
            <summary>
            For debugging and other purposes, might want the source name.
            Have ANTLR provide a hook for this property.
            </summary>
            <returns>The source name</returns>
        </member>
        <member name="P:Antlr.Runtime.BaseRecognizer.TokenNames">
            <summary>
            Used to print out token names like ID during debugging and
            error reporting.  The generated parsers implement a method
            that overrides this to point to their string[] tokenNames.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.BitSet">
            <summary>
            A stripped-down version of org.antlr.misc.BitSet that is just
            good enough to handle runtime requirements such as FOLLOW sets
            for automatic error recovery.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.BitSet.#ctor">
            <summary>Construct a bitset of size one word (64 bits) </summary>
        </member>
        <member name="M:Antlr.Runtime.BitSet.#ctor(System.UInt64[])">
            <summary>Construction from a static array of ulongs </summary>
        </member>
        <member name="M:Antlr.Runtime.BitSet.#ctor(System.Collections.Generic.IList{System.Int32})">
            <summary>Construction from a list of integers </summary>
        </member>
        <member name="M:Antlr.Runtime.BitSet.#ctor(System.Int32)">
            <summary>Construct a bitset given the size</summary>
            <param name="nbits">The size of the bitset in bits</param>
        </member>
        <member name="M:Antlr.Runtime.BitSet.Or(Antlr.Runtime.BitSet)">
            <summary>return "this | a" in a new set </summary>
        </member>
        <member name="M:Antlr.Runtime.BitSet.Add(System.Int32)">
            <summary>Or this element into this set (grow as necessary to accommodate)</summary>
        </member>
        <member name="M:Antlr.Runtime.BitSet.GrowToInclude(System.Int32)">
            <summary> Grows the set to a larger number of bits.</summary>
            <param name="bit">element that must fit in set
            </param>
        </member>
        <member name="M:Antlr.Runtime.BitSet.LengthInLongWords">
            <summary>return how much space is being used by the bits array not
            how many actually have member bits on.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.BitSet.MOD_MASK">
            <summary> We will often need to do a mod operator (i mod nbits).
             Its turns out that, for powers of two, this mod operation is
              same as <![CDATA[(i & (nbits-1))]]>.  Since mod is slow, we use a precomputed 
             mod mask to do the mod instead.
             </summary>
        </member>
        <member name="F:Antlr.Runtime.BitSet.bits">
            <summary>The actual data bits </summary>
        </member>
        <member name="M:Antlr.Runtime.BitSet.SetSize(System.Int32)">
            <summary> Sets the size of a set.</summary>
            <param name="nwords">how many words the new set should be
            </param>
        </member>
        <member name="T:Antlr.Runtime.CharStreamState">
            <summary>
            This is the complete state of a stream.
            
            When walking ahead with cyclic DFA for syntactic predicates, we 
            need to record the state of the input stream (char index, line, 
            etc...) so that we can rewind the state after scanning ahead.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.CharStreamState.p">
            <summary>Index into the char stream of next lookahead char </summary>
        </member>
        <member name="F:Antlr.Runtime.CharStreamState.line">
            <summary>What line number is the scanner at before processing buffer[p]? </summary>
        </member>
        <member name="F:Antlr.Runtime.CharStreamState.charPositionInLine">
            <summary>What char position 0..n-1 in line is scanner before processing buffer[p]? </summary>
        </member>
        <member name="P:Antlr.Runtime.IToken.Line">
            <summary>The line number on which this token was matched; line=1..n</summary>
        </member>
        <member name="P:Antlr.Runtime.IToken.CharPositionInLine">
            <summary>
            The index of the first character relative to the beginning of the line 0..n-1
            </summary>
        </member>
        <member name="P:Antlr.Runtime.IToken.TokenIndex">
            <summary>
            An index from 0..n-1 of the token object in the input stream
            </summary>
            <remarks>
            This must be valid in order to use the ANTLRWorks debugger.
            </remarks>
        </member>
        <member name="P:Antlr.Runtime.IToken.Text">
            <summary>The text of the token</summary>
            <remarks>
            When setting the text, it might be a NOP such as for the CommonToken,
            which doesn't have string pointers, just indexes into a char buffer.
            </remarks>
        </member>
        <member name="F:Antlr.Runtime.CommonToken.text">
            <summary>We need to be able to change the text once in a while.  If
            this is non-null, then getText should return this.  Note that
            start/stop are not affected by changing this.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.CommonToken.index">
            <summary>What token number is this from 0..n-1 tokens; &lt; 0 implies invalid index </summary>
        </member>
        <member name="F:Antlr.Runtime.CommonToken.start">
            <summary>The char position into the input buffer where this token starts </summary>
        </member>
        <member name="F:Antlr.Runtime.CommonToken.stop">
            <summary>The char position into the input buffer where this token stops </summary>
        </member>
        <member name="T:Antlr.Runtime.CommonTokenStream">
            <summary>
            The most common stream of tokens is one where every token is buffered up
            and tokens are prefiltered for a certain channel (the parser will only
            see these tokens and cannot change the filter channel number during the
            parse).
            
            TODO: how to access the full token stream?  How to track all tokens matched per rule?
            </summary>
        </member>
        <member name="T:Antlr.Runtime.ITokenStream">
            <summary>A stream of tokens accessing tokens from a TokenSource </summary>
        </member>
        <member name="M:Antlr.Runtime.ITokenStream.LT(System.Int32)">
            <summary>
            Get Token at current input pointer + i ahead (where i=1 is next 
            Token).
            i &lt; 0 indicates tokens in the past.  So -1 is previous token and -2 is
            two tokens ago. LT(0) is undefined.  For i>=n, return Token.EOFToken.
            Return null for LT(0) and any index that results in an absolute address
            that is negative.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ITokenStream.Get(System.Int32)">
            <summary>
            Get a token at an absolute index i; 0..n-1.  This is really only
            needed for profiling and debugging and token stream rewriting.
            If you don't want to buffer up tokens, then this method makes no
            sense for you.  Naturally you can't use the rewrite stream feature.
            I believe DebugTokenStream can easily be altered to not use
            this method, removing the dependency.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ITokenStream.ToString(System.Int32,System.Int32)">
            <summary>Return the text of all tokens from start to stop, inclusive.
            If the stream does not buffer all the tokens then it can just
            return "" or null;  Users should not access $ruleLabel.text in
            an action of course in that case.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ITokenStream.ToString(Antlr.Runtime.IToken,Antlr.Runtime.IToken)">
            <summary>Because the user is not required to use a token with an index stored
            in it, we must provide a means for two token objects themselves to
            indicate the start/end location.  Most often this will just delegate
            to the other toString(int,int).  This is also parallel with
            the TreeNodeStream.toString(Object,Object).
            </summary>
        </member>
        <member name="P:Antlr.Runtime.ITokenStream.TokenSource">
            <summary>Where is this stream pulling tokens from?  This is not the name, but
            the object that provides Token objects.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.CommonTokenStream.tokens">
            <summary>Record every single token pulled from the source so we can reproduce
            chunks of it later.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.CommonTokenStream.channelOverrideMap">
            <summary><![CDATA[Map<tokentype, channel>]]> to override some Tokens' channel numbers </summary>
        </member>
        <member name="F:Antlr.Runtime.CommonTokenStream.discardSet">
            <summary><![CDATA[Set<tokentype>;]]> discard any tokens with this type </summary>
        </member>
        <member name="F:Antlr.Runtime.CommonTokenStream.channel">
            <summary>Skip tokens on any channel but this one; this is how we skip whitespace... </summary>
        </member>
        <member name="F:Antlr.Runtime.CommonTokenStream.discardOffChannelTokens">
            <summary>By default, track all incoming tokens </summary>
        </member>
        <member name="F:Antlr.Runtime.CommonTokenStream.lastMarker">
            <summary>Track the last Mark() call result value for use in Rewind().</summary>
        </member>
        <member name="F:Antlr.Runtime.CommonTokenStream.p">
            <summary>
            The index into the tokens list of the current token (next token
            to consume).  p==-1 indicates that the tokens list is empty
            </summary>
        </member>
        <member name="M:Antlr.Runtime.CommonTokenStream.LT(System.Int32)">
            <summary>Get the ith token from the current position 1..n where k=1 is the
            first symbol of lookahead.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.CommonTokenStream.Get(System.Int32)">
            <summary>Return absolute token i; ignore which channel the tokens are on;
            that is, count all tokens not just on-channel tokens.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.CommonTokenStream.Consume">
            <summary>Move the input pointer to the next incoming token.  The stream
            must become active with LT(1) available.  Consume() simply
            moves the input pointer so that LT(1) points at the next
            input symbol. Consume at least one token.
            
            Walk past any token not on the channel the parser is listening to.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.CommonTokenStream.FillBuffer">
            <summary>Load all tokens from the token source and put in tokens.
            This is done upon first LT request because you might want to
            set some token type / channel overrides before filling buffer.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.CommonTokenStream.SkipOffTokenChannels(System.Int32)">
            <summary>Given a starting index, return the index of the first on-channel
            token.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.CommonTokenStream.SetTokenTypeChannel(System.Int32,System.Int32)">
            <summary>
            A simple filter mechanism whereby you can tell this token stream
            to force all tokens of type ttype to be on channel.
            </summary>
            
            <remarks>
            For example,
            when interpreting, we cannot exec actions so we need to tell
            the stream to force all WS and NEWLINE to be a different, ignored
            channel.
            </remarks>
        </member>
        <member name="M:Antlr.Runtime.CommonTokenStream.GetTokens(System.Int32,System.Int32,Antlr.Runtime.BitSet)">
            <summary>Given a start and stop index, return a List of all tokens in
            the token type BitSet.  Return null if no tokens were found.  This
            method looks at both on and off channel tokens.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.CommonTokenStream.LB(System.Int32)">
            <summary>Look backwards k tokens on-channel tokens </summary>
        </member>
        <member name="P:Antlr.Runtime.CommonTokenStream.TokenSource">
            <summary>
            Gets or sets the token source for this stream (i.e. the source 
            that supplies the stream with Token objects).
            </summary>
            
            <remarks>
            Setting the token source resets the stream.
            </remarks>
        </member>
        <member name="T:Antlr.Runtime.DFA">
            <summary>
             A DFA implemented as a set of transition tables.
            </summary>
            <remarks>
            <para>
            Any state that has a semantic predicate edge is special; those states are 
            generated with if-then-else structures in a SpecialStateTransition() 
            which is generated by cyclicDFA template.
            </para>
            <para>
            There are at most 32767 states (16-bit signed short). Could get away with byte 
            sometimes but would have to generate different types and the simulation code too.
            </para>
            <para>
            As a point of reference, the Tokens rule DFA for the lexer in the Java grammar 
            sample has approximately 326 states.
            </para>
            </remarks>
        </member>
        <member name="F:Antlr.Runtime.DFA.recognizer">
            <summary>
            Which recognizer encloses this DFA?  Needed to check backtracking
            </summary>
        </member>
        <member name="M:Antlr.Runtime.DFA.Predict(Antlr.Runtime.IIntStream)">
            <summary>
            From the input stream, predict what alternative will succeed using this 
            DFA (representing the covering regular approximation to the underlying CFL).  
            </summary>
            <param name="input">Input stream</param>
            <returns>Return an alternative number 1..n.  Throw an exception upon error.</returns>
        </member>
        <member name="M:Antlr.Runtime.DFA.Error(Antlr.Runtime.NoViableAltException)">
            <summary>
            A hook for debugging interface 
            </summary>
            <param name="nvae"></param>
        </member>
        <member name="T:Antlr.Runtime.EarlyExitException">
            <summary>
            The recognizer did not match anything for a (..)+ loop.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.RecognitionException">
            <summary>The root of the ANTLR exception hierarchy.</summary>
            <remarks>
            To avoid English-only error messages and to generally make things
            as flexible as possible, these exceptions are not created with strings,
            but rather the information necessary to generate an error.  Then
            the various reporting methods in Parser and Lexer can be overridden
            to generate a localized error message.  For example, MismatchedToken
            exceptions are built with the expected token type.
            So, don't expect getMessage() to return anything.
            
            You can access the stack trace, which means that you can compute the 
            complete trace of rules from the start symbol. This gives you considerable 
            context information with which to generate useful error messages.
            
            ANTLR generates code that throws exceptions upon recognition error and
            also generates code to catch these exceptions in each rule.  If you
            want to quit upon first error, you can turn off the automatic error
            handling mechanism using rulecatch action, but you still need to
            override methods mismatch and recoverFromMismatchSet.
            
            In general, the recognition exceptions can track where in a grammar a
            problem occurred and/or what was the expected input.  While the parser
            knows its state (such as current input symbol and line info) that
            state can change before the exception is reported so current token index
            is computed and stored at exception time.  From this info, you can
            perhaps print an entire line of input not just a single token, for example.
            Better to just say the recognizer had a problem and then let the parser
            figure out a fancy report.
            </remarks>
        </member>
        <member name="M:Antlr.Runtime.RecognitionException.#ctor">
            <summary>Used for remote debugger deserialization </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognitionException.input">
            <summary>What input stream did the error occur in? </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognitionException.index">
            <summary>
            What is index of token/char were we looking at when the error occurred?
            </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognitionException.token">
            <summary>
            The current Token when an error occurred.  Since not all streams
            can retrieve the ith Token, we have to track the Token object.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognitionException.node">
            <summary>[Tree parser] Node with the problem.</summary>
        </member>
        <member name="F:Antlr.Runtime.RecognitionException.c">
            <summary>The current char when an error occurred. For lexers. </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognitionException.line">
            <summary>Track the line at which the error occurred in case this is
            generated from a lexer.  We need to track this since the
            unexpected char doesn't carry the line info.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognitionException.approximateLineInfo">
            <summary>
            If you are parsing a tree node stream, you will encounter some
            imaginary nodes w/o line/col info.  We now search backwards looking
            for most recent token with line/col info, but notify getErrorHeader()
            that info is approximate.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.RecognitionException.Input">
            <summary>Returns the input stream in which the error occurred</summary>
        </member>
        <member name="P:Antlr.Runtime.RecognitionException.Index">
            <summary>
            Returns the token/char index in the stream when the error occurred
            </summary>
        </member>
        <member name="P:Antlr.Runtime.RecognitionException.Token">
            <summary>
            Returns the current Token when the error occurred (for parsers 
            although a tree parser might also set the token)
            </summary>
        </member>
        <member name="P:Antlr.Runtime.RecognitionException.Node">
            <summary>
            Returns the [tree parser] node where the error occured (for tree parsers).
            </summary>
        </member>
        <member name="P:Antlr.Runtime.RecognitionException.Char">
            <summary>
            Returns the current char when the error occurred (for lexers)
            </summary>
        </member>
        <member name="P:Antlr.Runtime.RecognitionException.CharPositionInLine">
            <summary>
            Returns the character position in the line when the error 
            occurred (for lexers)
            </summary>
        </member>
        <member name="P:Antlr.Runtime.RecognitionException.Line">
            <summary>
            Returns the line at which the error occurred (for lexers)
            </summary>
        </member>
        <member name="P:Antlr.Runtime.RecognitionException.UnexpectedType">
            <summary>
            Returns the token type or char of the unexpected input element
            </summary>
        </member>
        <member name="M:Antlr.Runtime.EarlyExitException.#ctor">
            <summary>Used for remote debugger deserialization </summary>
        </member>
        <member name="T:Antlr.Runtime.FailedPredicateException">
            <summary>
            A semantic predicate failed during validation.  Validation of predicates
            occurs when normally parsing the alternative just like matching a token.
            Disambiguating predicate evaluation occurs when we hoist a predicate into
            a prediction decision.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.FailedPredicateException.#ctor">
            <summary>Used for remote debugger deserialization </summary>
        </member>
        <member name="T:Antlr.Runtime.ITokenSource">
            <summary>
            A source of tokens must provide a sequence of tokens via NextToken()
            and also must reveal it's source of characters; CommonToken's text is
            computed from a CharStream; it only store indices into the char stream.
            
            Errors from the lexer are never passed to the parser.  Either you want
            to keep going or you do not upon token recognition error.  If you do not
            want to continue lexing then you do not want to continue parsing.  Just
            throw an exception not under RecognitionException and Java will naturally
            toss you all the way out of the recognizers.  If you want to continue
            lexing then you should not throw an exception to the parser--it has already
            requested a token.  Keep lexing until you get a valid one.  Just report
            errors and keep going, looking for a valid token.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ITokenSource.NextToken">
            <summary>
            Returns a Token object from the input stream (usually a CharStream).
            Does not fail/return upon lexing error; just keeps chewing on the 
            characters until it gets a good one; errors are not passed through 
            to the parser.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.ITokenSource.SourceName">
            <summary>
            Where are you getting tokens from? normally the implication will simply
            ask lexers input stream.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Lexer">
            <summary>
            A lexer is recognizer that draws input symbols from a character stream.
            lexer grammars result in a subclass of this object. A Lexer object
            uses simplified Match() and error recovery mechanisms in the interest
            of speed.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Lexer.NextToken">
            <summary>
            Return a token from this source; i.e., Match a token on the char stream.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Lexer.Skip">
            <summary>
            Instruct the lexer to skip creating a token for current lexer rule and 
            look for another token.  NextToken() knows to keep looking when a lexer 
            rule finishes with token set to SKIP_TOKEN.  Recall that if token==null 
            at end of any token rule, it creates one for you and emits it. 
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Lexer.mTokens">
            <summary>This is the lexer entry point that sets instance var 'token' </summary>
        </member>
        <member name="M:Antlr.Runtime.Lexer.Emit(Antlr.Runtime.IToken)">
            <summary>
            Currently does not support multiple emits per nextToken invocation
            for efficiency reasons.  Subclass and override this method and
            nextToken (to push tokens into a list and pull from that list rather
            than a single variable as this implementation does).
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Lexer.Emit">
             <summary>
             The standard method called to automatically emit a token at the 
             outermost lexical rule.  The token object should point into the 
             char buffer start..stop.  If there is a text override in 'text', 
             use that to set the token's text. 
             </summary>
             <remarks><para>Override this method to emit custom Token objects.</para>
             <para>If you are building trees, then you should also override
             Parser or TreeParser.getMissingSymbol().</para>
            </remarks>
        </member>
        <member name="M:Antlr.Runtime.Lexer.Recover(Antlr.Runtime.RecognitionException)">
            <summary>
            Lexers can normally Match any char in it's vocabulary after matching
            a token, so do the easy thing and just kill a character and hope
            it all works out.  You can instead use the rule invocation stack
            to do sophisticated error recovery if you are in a Fragment rule.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.Lexer.input">
            <summary>Where is the lexer drawing characters from? </summary>
        </member>
        <member name="P:Antlr.Runtime.Lexer.CharStream">
            <summary>Set the char stream and reset the lexer </summary>
        </member>
        <member name="P:Antlr.Runtime.Lexer.CharIndex">
            <summary>What is the index of the current character of lookahead? </summary>
        </member>
        <member name="P:Antlr.Runtime.Lexer.Text">
            <summary>
            Gets or sets the 'lexeme' for the current token.
            </summary>
            <remarks>
            <para>
            The getter returns the text matched so far for the current token or any 
            text override.
            </para>
            <para>
            The setter sets the complete text of this token. It overrides/wipes any 
            previous changes to the text.
            </para>
            </remarks>
        </member>
        <member name="M:Antlr.Runtime.MismatchedSetException.#ctor">
            <summary>Used for remote debugger deserialization </summary>
        </member>
        <member name="M:Antlr.Runtime.MismatchedNotSetException.#ctor">
            <summary>Used for remote debugger deserialization </summary>
        </member>
        <member name="M:Antlr.Runtime.MismatchedRangeException.#ctor">
            <summary>
            Used for remote debugger deserialization
            </summary>
        </member>
        <member name="T:Antlr.Runtime.MismatchedTokenException">
            <summary>
            A mismatched char or Token or tree node.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.MismatchedTokenException.#ctor">
            <summary>
            Used for remote debugger deserialization
            </summary>
        </member>
        <member name="T:Antlr.Runtime.MissingTokenException">
            <summary>
            We were expecting a token but it's not found. The current token
            is actually what we wanted next. Used for tree node errors too.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.MissingTokenException.#ctor">
            <summary>
            Used for remote debugger deserialization
            </summary>
        </member>
        <member name="M:Antlr.Runtime.NoViableAltException.#ctor">
            <summary>Used for remote debugger deserialization</summary>
        </member>
        <member name="T:Antlr.Runtime.Parser">
            <summary>A parser for TokenStreams.  Parser grammars result in a subclass
            of this.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.Parser.TokenStream">
            <summary>Set the token stream and reset the parser </summary>
        </member>
        <member name="T:Antlr.Runtime.ParserRuleReturnScope">
            <summary>
            Rules that return more than a single value must return an object
            containing all the values.  Besides the properties defined in
            RuleLabelScope.PredefinedRulePropertiesScope there may be user-defined
            return values.  This class simply defines the minimum properties that
            are always defined and methods to access the others that might be
            available depending on output option such as template and tree.
            
            Note text is not an actual property of the return value, it is computed
            from start and stop using the input stream's ToString() method.  I
            could add a ctor to this so that we can pass in and store the input
            stream, but I'm not sure we want to do that.  It would seem to be undefined
            to get the .text property anyway if the rule matches tokens from multiple
            input streams.
            
            I do not use getters for fields of objects that are used simply to
            group values such as this aggregate.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.RuleReturnScope">
            <summary>
            Rules can return start/stop info as well as possible trees and templates
            </summary>
        </member>
        <member name="P:Antlr.Runtime.RuleReturnScope.Start">
            <summary>Return the start token or tree </summary>
        </member>
        <member name="P:Antlr.Runtime.RuleReturnScope.Stop">
            <summary>Return the stop token or tree </summary>
        </member>
        <member name="P:Antlr.Runtime.RuleReturnScope.Tree">
            <summary>Has a value potentially if output=AST; </summary>
        </member>
        <member name="P:Antlr.Runtime.RuleReturnScope.Template">
            <summary>
            Has a value potentially if output=template; 
            Don't use StringTemplate type to avoid dependency on ST assembly
            </summary>
        </member>
        <member name="P:Antlr.Runtime.ParserRuleReturnScope.Start">
            <summary>Return the start token or tree </summary>
        </member>
        <member name="P:Antlr.Runtime.ParserRuleReturnScope.Stop">
            <summary>Return the stop token or tree </summary>
        </member>
        <member name="T:Antlr.Runtime.RecognizerSharedState">
            <summary>
            The set of fields needed by an abstract recognizer to recognize input
            and recover from errors 
            </summary>
            <remarks>
            As a separate state object, it can be shared among multiple grammars; 
            e.g., when one grammar imports another.
            These fields are publicly visible but the actual state pointer per 
            parser is protected.
            </remarks>
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.following">
            <summary>
            Tracks the set of token types that can follow any rule invocation.
            Stack grows upwards.  When it hits the max, it grows 2x in size
            and keeps going.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.errorRecovery">
            <summary>
            This is true when we see an error and before having successfully
            matched a token.  Prevents generation of more than one error message
            per error.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.lastErrorIndex">
            <summary>
            The index into the input stream where the last error occurred.
            </summary>
            <remarks>
            This is used to prevent infinite loops where an error is found
            but no token is consumed during recovery...another error is found,
            ad naseum.  This is a failsafe mechanism to guarantee that at least
            one token/tree node is consumed for two errors.
            </remarks>
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.failed">
            <summary>
            In lieu of a return value, this indicates that a rule or token
            has failed to match.  Reset to false upon valid token match.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.syntaxErrors">
            <summary>
            Did the recognizer encounter a syntax error?  Track how many.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.backtracking">
            <summary>
            If 0, no backtracking is going on.  Safe to exec actions etc...
            If >0 then it's the level of backtracking.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.ruleMemo">
            <summary>
            An array[size num rules] of Map&lt;Integer,Integer&gt; that tracks
            the stop token index for each rule.
            </summary>
            <remarks>
             ruleMemo[ruleIndex] is the memoization table for ruleIndex.  
             For key ruleStartIndex, you get back the stop token for 
             associated rule or MEMO_RULE_FAILED.
             
             This is only used if rule memoization is on (which it is by default).
             </remarks>
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.token">
            <summary>
            Token object normally returned by NextToken() after matching lexer rules.
            </summary>
            <remarks>
            The goal of all lexer rules/methods is to create a token object.
            This is an instance variable as multiple rules may collaborate to
            create a single token.  nextToken will return this object after
            matching lexer rule(s).  If you subclass to allow multiple token
            emissions, then set this to the last token to be matched or
            something nonnull so that the auto token emit mechanism will not
            emit another token.
            </remarks>
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.tokenStartCharIndex">
            <summary>
            What character index in the stream did the current token start at?
            </summary>
            <remarks>
            Needed, for example, to get the text for current token.  Set at
            the start of nextToken.
            </remarks>
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.tokenStartLine">
            <summary>
            The line on which the first character of the token resides
            </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.tokenStartCharPositionInLine">
            <summary>The character position of first character within the line</summary>
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.channel">
            <summary>The channel number for the current token</summary>
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.type">
            <summary>The token type for the current token</summary>
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.text">
            <summary>
            You can set the text for the current token to override what is in
            the input char buffer.  Use setText() or can set this instance var.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.Token.DOWN">
            <summary>imaginary tree navigation type; traverse "get child" link </summary>
        </member>
        <member name="F:Antlr.Runtime.Token.UP">
            <summary>imaginary tree navigation type; finish with a child list </summary>
        </member>
        <member name="F:Antlr.Runtime.Token.DEFAULT_CHANNEL">
            <summary>
            All tokens go to the parser (unless skip() is called in that rule)
            on a particular "channel".  The parser tunes to a particular channel
            so that whitespace etc... can go to the parser on a "hidden" channel.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.Token.HIDDEN_CHANNEL">
            <summary>
            Anything on different channel than DEFAULT_CHANNEL is not parsed by parser.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.Token.SKIP_TOKEN">
            <summary>
            In an action, a lexer rule can set token to this SKIP_TOKEN and ANTLR
            will avoid creating a token for this symbol and try to fetch another.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.UnwantedTokenException">
            <summary>
            An extra token while parsing a TokenStream.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.UnwantedTokenException.#ctor">
            <summary>
            Used for remote debugger deserialization
            </summary>
        </member>
    </members>
</doc>
